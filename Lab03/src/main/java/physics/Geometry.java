package physics;import java.io.Serializable;/**************************************************************************** * Copyright (C) 1999-2001 by the Massachusetts Institute of Technology, *                       Cambridge, Massachusetts. * *                        All Rights Reserved * * Permission to use, copy, modify, and distribute this software and * its documentation for any purpose and without fee is hereby * granted, provided that the above copyright notice appear in all * copies and that both that copyright notice and this permission * notice appear in supporting documentation, and that MIT's name not * be used in advertising or publicity pertaining to distribution of * the software without specific, written prior permission. *   * THE MASSACHUSETTS INSTITUTE OF TECHNOLOGY DISCLAIMS ALL WARRANTIES * WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL THE MASSACHUSETTS * INSTITUTE OF TECHNOLOGY BE LIABLE FOR ANY SPECIAL, INDIRECT OR * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. * * * @author: Matt Frank, MIT Laboratory for Computer Science, *          mfrank@lcs.mit.edu *          1999-Apr-03 * * @author: Rob Pinder, Phil Sarin, Lik Mui *          Spring 2000 *          Exception handling and argument type refinemnt * * @author: Jeffrey Sheldon (jeffshel@mit.edu) *          Fall 2000, Spring 2001 *          Major rewrites and improvements to iterative solving * * @author: Jeremy Nimmer (jwnimmer@alum.mit.edu) *          Fall 2000, Spring 2001 *          Editorial role (testing and specification editing) * * Version: $Id: Geometry.java,v 1.1 2002/08/21 21:49:40 kirky Exp $ * ***************************************************************************//** * The Geometry library contains procedural abstractions which are useful in * modeling the physical interactions between objects. * * The library is described in terms of these concepts: *  * object - a ball or a bouncer ball - a circle with position and velocity * bouncer - a line segment or circle with position and angular velocity *  * *  * The intended use of the Geometry library is as follows: * *  * The client calls the timeUntilCollision() methods to calculate the times at * which the ball(s) will collide with each of the bouncers or with another * ball. The minimum of all these times (call it "mintime") is the time of the * next collision. * *  * The client updates the position of the ball(s) and the bouncers to account * for mintime passing. At this point, the ball and the object it is about to * hit are exactly adjacent to one another. * *  * The client calls the appropriate reflect() method to calculate the change in * the ball's velocity. * * The client updates the ball's velocity and repeats back to step 1. * *  * * name="constant_velocity" * * The timeUntilCollision() methods assume constant ball velocity. That is, no * force will be acting on the ball, so it will follow a straight-line path. * Therefore, if external forces (such as gravity or friction) need to be * accounted for, the client must do so before or after the of the * "time until / update position / reflect" series of steps - never inbetween * those three steps. *  * name="endpoint_effects" * * Important note: The methods which deal with line segment bouncers do NOT deal * with the end-points of the segment. To ensure realistic behavior, shapes * should be constructed from a combination of line segments with zero-radius * circles at the end points. * *  * For example: A ball is located at (0,0) and is moving in the (1,1) direction * towards two line segments; one segments spans the points (1,1),(1,2) and the * other spans (1,1),(2,1). The ball will hit the ends of both line segments at * a 45 degree angle and something REALLY WEIRD will happen. However, if a * circle with zero radius is placed at (1,1) then the ball will bounce off the * circle in the expected manner. **/public class Geometry {	// nobody should be constructing a "Geometry"	private Geometry() {	}	private static GeometryInterface geometry = new GeometryImpl();	/**	 * @param impl	 *            the object to be used as the singleton	 *	 *            changes which implementation of GeometryInterface will be used	 *            to service the static methods of this class. Most users will	 *            prefer to use setForesight or setTuningParameters instead.	 *	 * @see #setForesight	 * @see #setTuningParameters	 **/	public static void setGeometry(GeometryInterface impl) {		if (impl == null) {			throw new IllegalArgumentException();		}		geometry = impl;	}	/**	 * Modifies the behavior of this class to use the specified maximumForesight	 * and numberOfSlices. If useDoughnut is true then doughnut optimizations	 * are enabled. The values used by default are &lt;+Inf, true, 15&gt;. Many	 * uses may prefer to simply use setForesight instead.	 *	 * @param maximumForesight	 *            The maximal time in the future that a collision will be	 *            searched for. Collisions may still be returned that happen	 *            farther than maximumForesight in the future, but no extra	 *            effort will be made to find them. If set to +Infinity,	 *            useDoughnut must also be true.	 *	 * @param useDoughnut	 *            When true, the timeUntilRotating* methods perform extra	 *            calculations to reduce the time during which collisions are	 *            searched for. If maximumForesight is small, it is sometimes	 *            quicker to skip these additional checks. Must be true if	 *            maximumForesight is +Infinity.	 *	 * @param numberOfSlices	 *            The number of slices that the time being searched for a	 *            possible collision is divided into. Since some methods	 *            (noteably timeUntilRotating*) cannot use closed form formula,	 *            they must search for possible collisions over some time frame.	 *            Increasing the size of this will decrease the likelihood of	 *            one of the timeUntilRotating* methods missing a collision, but	 *            will also cause them to run slower.	 *	 * @see #setForesight	 * @see Double#POSITIVE_INFINITY	 **/	public static void setTuningParameters(double maximumForesight,			boolean useDoughnut, int numberOfSlices) {		if (useDoughnut) {			setGeometry(new GeometryImpl(maximumForesight, numberOfSlices));		} else {			setGeometry(new SimpleGeometry(maximumForesight, numberOfSlices));		}	}	/**	 * Modifies the behavior of this class to use the specified	 * maximumForesight.	 *	 * @param maximumForesight	 *            The maximal time in the future that a collision will be	 *            searched for. Collisions may still be returned that happen	 *            farther than maximumForesight in the future, but no extra	 *            effort will be made to find them.	 *	 * @see Double#POSITIVE_INFINITY	 **/	public static void setForesight(double maximumForesight) {		if (maximumForesight <= 0.1) {			setGeometry(new SimpleGeometry(maximumForesight, 15));		} else {			setGeometry(new GeometryImpl(maximumForesight, 15));		}	}	/**	 * DoublePair is a simple immutable record type representing a pair of	 * doubles.	 **/	public static class DoublePair implements Serializable {		public final double d1;		public final double d2;		/**		 * Creates a DoublePair with d1 and d2 as given		 **/		public DoublePair(double d1, double d2) {			this.d1 = d1;			this.d2 = d2;		}		/**		 * Creates a DoublePair with d1 and d2 both set to the given argumen		 **/		public DoublePair(double both) {			this(both, both);		}		public boolean areFinite() {			return !Double.isInfinite(d1) && !Double.isInfinite(d2)					&& !Double.isNaN(d1) && !Double.isNaN(d2);		}		public String toString() {			return "[" + d1 + "," + d2 + "]";		}		public boolean equals(Object o) {			return (o instanceof DoublePair) && equals((DoublePair) o);		}		public boolean equals(DoublePair p) {			if (p == null)				return false;			return (d1 == p.d1) && (d2 == p.d2);		}		public int hashCode() {			return (new Double(d1)).hashCode() + (new Double(d2)).hashCode();		}	}	/**	 * VectPair is a simple immutable record type representing a pair of Vects.	 * 	 * @see Vect	 **/	public static class VectPair implements Serializable {		public final Vect v1;		public final Vect v2;		/**		 * Creates a VectPair with v1 and v2 as given		 **/		public VectPair(Vect v1, Vect v2) {			this.v1 = v1;			this.v2 = v2;		}		public String toString() {			return "[" + v1 + "," + v2 + "]";		}		public boolean equals(Object o) {			return (o instanceof VectPair) && equals((VectPair) o);		}		public boolean equals(VectPair p) {			if (p == null)				return false;			return ((v1 == null) ? (p.v1 == null) : v1.equals(p.v1))					&& ((v2 == null) ? (p.v2 == null) : v2.equals(p.v2));		}		public int hashCode() {			return ((v1 == null) ? 0 : (3 * v1.hashCode()))					+ ((v2 == null) ? 0 : (7 * v2.hashCode()));		}	}	/**	 * DoublePair with both d1 and d2 set to Double.NaN	 * 	 * @see Double#NaN	 **/	public static final DoublePair DOUBLE_PAIR_NAN = new DoublePair(Double.NaN);	/**	 * Solves the quadratic equation.	 *	 * @return a pair containing the roots of the equation a*x^2 + b*x + c = 0	 *         with the lesser of the two roots in result.d1. If no real roots	 *         exist, the returned pair will contain NaN for both values.	 *	 * @see Double#NaN	 **/	public static DoublePair quadraticSolution(double a, double b, double c) {		return geometry.quadraticSolution(a, b, c);	}	/**	 * Solves the quadratic equation.	 *	 * @return the lesser of the two roots of the quadratic equation specified	 *         by a*x^2 + b*x + c = 0, or NaN if no real roots exist.	 *	 * @see Double#NaN	 **/	public static double minQuadraticSolution(double a, double b, double c) {		return geometry.minQuadraticSolution(a, b, c);	}	/***************************************************************************	 *	 * METHODS FOR LINE SEGMENTS	 *	 * Suppose we have a line running through the points <x,y> and <w,z>. And we	 * have a point <a,b>. We'd like to find the distance from the point to the	 * line. We can calculate this by finding the minimum distance between the	 * point and all points on the line. (Write the line as a function of s:	 * j[s] = x + (w-x)s, k[s] = y + (z-y)s, then write the distance squared as	 * a function of s: (a - j[s])^2 + (b - k[s])^2 Take the derivative with	 * respect to s and set it equal 0. The result is that the distance squared	 * between the point and the line is:	 *	 * (b(x-w) - a(y-z) + (w y - x z))^2 / ((x-w)^2 + (y-z)^2)	 *	 *	 * Furthermore, the point on the line that is perpendicular to the point is	 * given by:	 *	 * minS = ((w-x)(a-x) + (z-y)(b-y)) / ((w-x)^2 + (y-z)^2) minX = j[minS],	 * minY = k[minS]	 *	 * Okay, now assume that the point is moving. a[t] = u t + c, b[t] = v t +	 * d. We want to find the time, t, at which the distance between the point	 * and the line will be exactly "r".	 *	 * Then the numerator of the previous expression will be a quadratic	 * expression of the variable t, with At^2 + Bt + C where	 *	 * F = (v(x-w) - u(y-z)) G = (d(x-w) - c(y-z) + (w y - x z)) H = ((x-w)^2 +	 * (y-z)^2)	 *	 * A = F^2 B = 2 F G C = G^2	 *	 * So to find the answer we let: Cprime = C - r^2 H	 *	 * and finally:	 *	 * t = (-B +/- Sqrt(B^2 - 4 A Cprime)) / (2 A)	 *	 ***************************************************************************/	/**	 * Returns the point on line which forms a line with point that is	 * perpendicular to line.	 * 	 * @param line	 *            has non-zero length	 * @param point	 *            Vect	 * @return the point on line which forms a line with point that is	 *         perpendicular to line, or null if no such point exists within the	 *         given line segment.	 * @see #perpendicularPointWholeLine(LineSegment, Vect)	 */	static public Vect perpendicularPoint(LineSegment line, Vect point) {		return geometry.perpendicularPoint(line, point);	}	/**	 * Returns the point on the infinitly long line represented by line which	 * forms a line with point that is perpendicular to line.	 *	 * Requires: line has non-zero length	 *	 * @return the point on the infinitly long line represented by line which	 *         forms a line with point that is perpendicular to line, or null if	 *         no such point exists within the given line segment.	 *	 * @see #perpendicularPoint(LineSegment, Vect)	 **/	public static Vect perpendicularPointWholeLine(LineSegment line, Vect point) {		return geometry.perpendicularPointWholeLine(line, point);	}	/**	 * Accounts for the effects of inelastic collisions given the intial and	 * resulting velocities of the collision assuming elasticity.	 *	 * Requires: rCoeff more or equal to 0	 *	 * given an initial velocity, incidentVect, and the velocity resulting from	 * an elastic collision, reflectedVect, and a reflection coefficient,	 * rCoeff, returns the resulting velocity of the collision had it been	 * inelastic with the given reflection coefficient. If the reflection	 * coefficient is 1.0, the resulting velocity will be equal to	 * reflectedVect. A reflection coefficient of 0 implies that the collision	 * will absorb any energy that was reflected in the elastic case.	 *	 * @param incidentVect	 *            the intial velocity of the ball	 * @param reflectedVect	 *            the resulting velocity after the collision assuming	 *            elasticity.	 * @param rCoeff	 *            the reflection coefficent.	 *	 * @return the resulting velocity after an inelastic collision.	 **/	public static Vect applyReflectionCoeff(Vect incidentVect,			Vect reflectedVect, double rCoeff) {		return geometry.applyReflectionCoeff(incidentVect, reflectedVect,				rCoeff);	}	/**	 * Computes the time until a ball, represented by a circle, travelling at a	 * specified velocity collides with a specified line segment.	 *	 * Requires: line has non-zero length	 *	 * computes the time until a circular ball travelling at a specified	 * velocity collides with a specified line segment. If no collision will	 * occur, POSITIVE_INFINITY is returned. This method assumes that the ball	 * will travel with constant velocity until impact.	 *	 * @param line	 *            the line segment representing a wall or (part of) an object	 *            that might be collided with	 *	 * @param ball	 *            a circle indicate the size and location of a ball which might	 *            collide with the given line segment	 *	 * @param velocity	 *            the velocity of the ball before impact	 *	 * @return the time until collision, or POSITIVE_INFINITY if the collision	 *         will not occur	 *	 * @see Double#POSITIVE_INFINITY and see  "#endpoint_effects"endpoint effects	 **/	public static double timeUntilWallCollision(LineSegment line, Circle ball,			Vect velocity) {		return geometry.timeUntilWallCollision(line, ball, velocity);	}	/**	 * Computes the new velocity of a ball after bouncing (reflecting) off a	 * wall.	 *	 * Requires: line has non-zero length, reflectionCoeff more or equal to 0	 *	 * computes the new velocity of a ball reflecting off of a wall. The	 * velocity resulting from this method corresponds to collision against a	 * surface with the given reflection coefficient. A reflection coefficient	 * of 1 indiciates a perfectly elastic collision. This method assumes that	 * the ball is at the point of impact.	 *	 * @param line	 *            the line segment representing the wall which is being hit	 *	 * @param velocity	 *            the velocity of the ball before impact	 *	 * @param reflectionCoeff	 *            the reflection coefficent	 *	 * @return the velocity of the ball after impacting the given wall	 **/	public static Vect reflectWall(LineSegment line, Vect velocity,			double reflectionCoeff) {		return geometry.reflectWall(line, velocity, reflectionCoeff);	}	/**	 * Computes the new velocity of a ball after bouncing (reflecting) off a	 * wall.	 *	 * Requires: line has non-zero length	 *	 * computes the new velocity of a ball reflecting off of a wall. The	 * velocity resulting from this method corresponds to a perfectly elastic	 * collision. This method assumes that the ball is at the point of impact.	 *	 * @param line	 *            the line segment representing the wall which is being hit	 *	 * @param velocity	 *            the velocity of the ball before impact	 *	 * @return the velocity of the ball after impacting the given wall	 **/	public static Vect reflectWall(LineSegment line, Vect velocity) {		return geometry.reflectWall(line, velocity);	}	/****************************************************************************	 *	 * METHODS FOR CIRCLES	 *	 ***************************************************************************/	/**	 * @return the square of the distance between two points represented by v1	 *         and v2.	 **/	static public double distanceSquared(Vect v1, Vect v2) {		return geometry.distanceSquared(v1, v2);	}	/**	 * @return the square of the distance between two points represented by (x1,	 *         y1) and (x2, y2).	 **/	static public double distanceSquared(double x1, double y1, double x2,			double y2) {		return geometry.distanceSquared(x1, y1, x2, y2);	}	/**	 * Computes the time until a ball represented by a circle, travelling at a	 * specified velocity collides with a specified circle.	 *	 * Requires: ball.radius more than 0	 * 	 * computes the time until a ball represented by a circle, travelling at a	 * specified velocity collides with a specified circle. If no collision will	 * occur POSITIVE_INFINITY is returned. This method assumes the ball travels	 * with constant velocity until impact.	 *	 * @param circle	 *            a circle representing the circle with which the ball may	 *            collide	 *	 * @param ball	 *            a circle representing the size and initial location of the	 *            ball	 *	 * @param velocity	 *            the velocity of the ball before impact	 *	 * @return the time until collision or POSITIVE_INFINITY if the collision	 *         will not occur	 *	 * @see Double#POSITIVE_INFINITY	 **/	static public double timeUntilCircleCollision(Circle circle, Circle ball,			Vect velocity) {		return geometry.timeUntilCircleCollision(circle, ball, velocity);	}	/**	 * Computes the new velocity of a ball reflecting off of a circle.	 *	 * Requires: reflectionCoeff more or equal to 0	 *	 * computes the new velocity of a ball reflecting off of a circle. The	 * velocity resulting from this method corresponds to a collision against a	 * surface with the given reflection coefficient. A reflection coefficient	 * of 1 indicates a perfectly elastic collision. This method assumes that	 * the ball is at the point of impact.	 *	 * @param circle	 *            the center point of the circle which is being hit	 *	 * @param ball	 *            the center point of the ball	 *	 * @param velocity	 *            the velocity of the ball before impact	 *	 * @param reflectionCoeff	 *            the reflection coefficient	 *	 * @return the velocity of the ball after impacting the given circle	 **/	public static Vect reflectCircle(Vect circle, Vect ball, Vect velocity,			double reflectionCoeff) {		return geometry.reflectCircle(circle, ball, velocity, reflectionCoeff);	}	/**	 * Computes the new velocity of a ball reflecting off of a circle.	 *	 * computes the new velocity of a ball reflecting off of a circle. The	 * velocity resulting from this method corresponds to a perfectly elastic	 * collision. This method assumes that the ball is at the point of impact.	 *	 * @param circle	 *            the center point of the circle which is being hit	 *	 * @param ball	 *            the center point of the ball	 *	 * @param velocity	 *            the velocity of the ball before impact	 *	 * @return the velocity of the ball after impacting the given circle	 **/	public static Vect reflectCircle(Vect circle, Vect ball, Vect velocity) {		return geometry.reflectCircle(circle, ball, velocity);	}	/****************************************************************************	 *	 * METHODS FOR ROTATING LINE SEGMENTS AND CIRCLES	 *	 ***************************************************************************/	/**	 * Rotates the point represented by p by a around the center of rotation,	 * cor, and returns the result.	 *	 * rotates the point represented by p by a around the center of rotation,	 * cor, and returns the result.	 *	 * @param point	 *            the initial location of the point to be rotated	 *	 * @param cor	 *            the point indicating the center of rotation	 *	 * @param a	 *            the amount by which to rotate point	 *	 * @return point point rotated around cor by a	 **/	public static Vect rotateAround(Vect point, Vect cor, Angle a) {		return geometry.rotateAround(point, cor, a);	}	/**	 * Rotates the line segment represented by line by a around the center of	 * rotation, cor, and returns the result.	 *	 * rotates the line segment represented by line by a around the center of	 * rotation, cor, and returns the result.	 *	 * @param line	 *            the initial location of the line segment to be rotated	 *	 * @param cor	 *            the point indicating the center of rotation	 *	 * @param a	 *            the amount by which to rotate point	 *	 * @return line segment line rotated around cor by a	 **/	public static LineSegment rotateAround(LineSegment line, Vect cor, Angle a) {		return geometry.rotateAround(line, cor, a);	}	/**	 * Rotates the circle represented by circle by a around the center of	 * rotation, cor, and returns the result.	 *	 * rotates the circle represented by circle by a around the center of	 * rotation, cor, and returns the result.	 *	 * @param circle	 *            the initial location of the circle to be rotated	 *	 * @param cor	 *            the point indicating the center of rotation	 *	 * @param a	 *            the amount by which to rotate point	 *	 * @return circle circle rotated around cor by a	 **/	public static Circle rotateAround(Circle circle, Vect cor, Angle a) {		return geometry.rotateAround(circle, cor, a);	}	/**	 * Computes the times when the point moving along the given trajectory will	 * intersect the given circle	 *	 * @param circle	 *            circle to find collisions with	 * 	 * @param velocity	 *            linear velocity of the point	 *	 * @return the times until intersection, with lesser result in d1, or +Infs	 *         if no collisions will occur	 *	 * @see Double#POSITIVE_INFINITY	 **/	public static DoublePair timeUntilCircleCollision(Circle circle,			Vect point, Vect velocity) {		return geometry.timeUntilCircleCollision(circle, point, velocity);	}	/**	 * Computes the time until a ball travelling at a specified velocity	 * collides with a rotating line segment.	 *	 * Requires: line has non-zero length	 *	 * computes the time until a circular ball travelling at a specified	 * velocity collides with a specified line segment which is rotating at a	 * fixed angular velocity about a fixed center of rotation.	 *	 * src="doc-files/rotate_line.gif"	 *	 * @param line	 *            the initial position of the rotating line segment (wall)	 *	 * @param center	 *            the center of rotation for line	 *	 * @param angularVelocity	 *            the angular velocity of the rotation of line in radians per	 *            second. A positive angular velocity denotes a rotation in the	 *            direction from the positive x-axis to the positive y-axis.	 *	 * @param ball	 *            the size and initial location of the ball	 *	 * @param velocity	 *            the initial velocity of the ball. The ball is assumed to	 *            travel at a constant velocity until impact.	 *	 * @return the time until collision or POSITIVE_INFINITY if no collision was	 *         detected.	 *	 * @see Double#POSITIVE_INFINITY href="endpoint_effects" endpoint effects	 **/	public static double timeUntilRotatingWallCollision(LineSegment line,			Vect center, double angularVelocity, Circle ball, Vect velocity) {		return geometry.timeUntilRotatingWallCollision(line, center,				angularVelocity, ball, velocity);	}	/**	 * Computes the new velocity of a ball reflecting off of a wall which is	 * rotating about a point with constant angular velocity.	 *	 * Requires: line has non-zero length and the ball is at the point of impact	 *	 * computes the new velocity of a ball reflecting off of a wall which is	 * rotating about a point with constant angular velocity. The velocity	 * resulting from this method corresponds to a perfectly elastic collision.	 * This method assumes that the ball is at the point of impact. If the ball	 * does not hit in between the endpoints of line, velocity is returned.	 *	 * @param line	 *            the line segment representing the initial position of the	 *            rotating wall	 *	 * @param center	 *            the point about which line rotates	 *	 * @param angularVelocity	 *            the angular velocity at which line rotates, in radians per	 *            second. A positive angular velocity denotes a rotation in the	 *            direction from the positive x-axis to the positive y-axis.	 *	 * @param velocity	 *            the velocity of the ball before impact	 *	 * @return the velocity of the ball after impacting the wall	 **/	public static Vect reflectRotatingWall(LineSegment line, Vect center,			double angularVelocity, Circle ball, Vect velocity) {		return geometry.reflectRotatingWall(line, center, angularVelocity,				ball, velocity);	}	/**	 * computes the new velocity of a ball reflecting off of a wall which is	 * rotating about a point with constant angular velocity. The velocity	 * resulting from this method corresponds to a collision against a surface	 * of the given reflection coefficient. A reflection coefficient of 1	 * indicates a perfectly elastic collision. This method assumes that the	 * ball is at the point of impact. If the ball does not hit in between the	 * endpoints of line, velocity is returned.	 * 	 * @param line	 *            the line segment representing the initial position of the	 *            rotating wall. line has non-zero length	 * @param center	 *            the point about which line rotates	 * @param angularVelocity	 *            the angular velocity at which line rotates, in radians per	 *            second. A positive angular velocity denotes a rotation in the	 *            direction from the positive x-axis to the positive y-axis.	 * @param ball	 *            the ball is at the point of impact	 * @param velocity	 *            the velocity of the ball before impact	 * @param reflectionCoeff	 *            reflectionCoeff above or equal to 0	 * @return the velocity of the ball after impacting the wall	 */	public static Vect reflectRotatingWall(LineSegment line, Vect center,			double angularVelocity, Circle ball, Vect velocity,			double reflectionCoeff) {		return geometry.reflectRotatingWall(line, center, angularVelocity,				ball, velocity, reflectionCoeff);	}	/**	 * Computes the time until a ball travelling at a specified velocity	 * collides with a rotating circle.	 *	 * computes the time until a circular ball travelling at a specified	 * velocity collides with a specified circle that is rotating about a given	 * center of rotation at a given angular velocity. If no collision will	 * occurr POSITIVE_INFINITY is returned. This method assumes the ball will	 * travel with constant velocity until impact.	 *	 * 	 * "doc-files/rotate_circle.gif"	 *	 * @param circle	 *            a circle representing the initial location and size of the	 *            rotating circle	 *	 * @param center	 *            the point around which the circle is rotating	 *	 * @param angularVelocity	 *            the angular velocity with which circle is rotating about	 *            center, in radians per second. A positive angular velocity	 *            denotes a rotation in the direction from the positive x-axis	 *            to the positive y-axis.	 *	 * @param ball	 *            a circle representing the size and initial position of the	 *            ball	 *	 * @param velocity	 *            the velocity of the ball before impact	 *	 * @see Double#POSITIVE_INFINITY	 **/	public static double timeUntilRotatingCircleCollision(Circle circle,			Vect center, double angularVelocity, Circle ball, Vect velocity) {		return geometry.timeUntilRotatingCircleCollision(circle, center,				angularVelocity, ball, velocity);	}	/**	 * Computes the new velocity of a ball reflected off of a rotating circle.	 *	 * Requires: the ball is at the point of impact	 *	 * computes the new velocity of a ball reflected off of a circle which is	 * rotating with constant angular velocity around a point. The velocity	 * resulting from this method corresponds to a perfectly elastic collision.	 *	 * @param circle	 *            the rotating circle	 *	 * @param center	 *            the point about which circle is rotating	 *	 * @param angularVelocity	 *            the angular velocity with which circle is rotating about	 *            center, in radians per second. A positive angular velocity	 *            denotes a rotation in the direction from the positive x-axis	 *            to the positive y-axis.	 *	 * @param ball	 *            the size and position of the ball before impact	 *	 * @param velocity	 *            the velocity of the ball before impact	 *	 * @return the velocity of the ball after impacting the rotating circle	 **/	public static Vect reflectRotatingCircle(Circle circle, Vect center,			double angularVelocity, Circle ball, Vect velocity) {		return geometry.reflectRotatingCircle(circle, center, angularVelocity,				ball, velocity);	}	/**	 * Computes the new velocity of a ball reflected off of a rotating circle.	 *	 * Requires: the ball is at the point of impact	 *	 * computes the new velocity of a ball reflected off of a circle which is	 * rotating with constant angular velocity around a point. The velocity	 * resulting from this method corresponds to a collision against a surface	 * with the given reflection coefficient. A reflection coefficient of 1.0	 * indicates a perfectly elastic collision.	 *	 * @param circle	 *            the rotating circle	 *	 * @param center	 *            the point about which circle is rotating	 *	 * @param angularVelocity	 *            the angular velocity with which circle is rotating about	 *            center, in radians per second. A positive angular velocity	 *            denotes a rotation in the direction from the positive x-axis	 *            to the positive y-axis.	 *	 * @param ball	 *            the size and position of the ball before impact	 *	 * @param velocity	 *            the velocity of the ball before impact	 * 	 * @param reflectionCoeff	 *            the reflection coefficient	 *	 * @return the velocity of the ball after impacting the rotating circle	 **/	public static Vect reflectRotatingCircle(Circle circle, Vect center,			double angularVelocity, Circle ball, Vect velocity,			double reflectionCoeff) {		return geometry.reflectRotatingCircle(circle, center, angularVelocity,				ball, velocity, reflectionCoeff);	}	/****************************************************************************	 *	 * METHODS FOR MULTI-BALL SIMULATIONS	 *	 ***************************************************************************/	/**	 * Computes the time until two balls collide.	 *	 * computes the time until two balls, represented by two circles, travelling	 * at specified constant velocities, collide. If no collision will occur	 * POSITIVE_INFINITY is returned. This method assumes that both balls will	 * travel at constant velocity until impact.	 *	 * @param ball1	 *            a circle representing the size and initial position of the	 *            first ball.	 *	 * @param vel1	 *            the velocity of the first ball before impact	 *	 * @param ball2	 *            a circle representing the size and initial position of the	 *            second ball.	 *	 * @param vel2	 *            the velocity of the second ball before impact	 *	 * @return the time until collision or POSITIVE_INFINITY if the collision	 *         will not occur	 *	 * @see Double#POSITIVE_INFINITY	 **/	public static double timeUntilBallBallCollision(Circle ball1, Vect vel1,			Circle ball2, Vect vel2) {		return geometry.timeUntilBallBallCollision(ball1, vel1, ball2, vel2);	}	/**	 * Computes the resulting velocities of two balls which collide.	 *	 * @param center1	 *            the position of the center of the first ball	 *	 * @param mass1	 *            the mass of the first ball above 0	 *	 * @param velocity1	 *            the velocity of the first ball before impact	 *	 * @param center2	 *            the position of the center of the second ball	 *	 * @param mass2	 *            the mass of the second ball above 0 and the distance between	 *            the two balls is approximately equal to the sum of their	 *            radii; that is, the balls are positioned at the point of	 *            impact.	 *	 * @param velocity2	 *            the velocity of the second ball before impact	 *	 * @return a VectPair, where the first Vect is the velocity of the first	 *         ball after the collision and the second Vect is the velocity of	 *         the second ball after the collision.	 **/	public static VectPair reflectBalls(Vect center1, double mass1,			Vect velocity1, Vect center2, double mass2, Vect velocity2) {		return geometry.reflectBalls(center1, mass1, velocity1, center2, mass2,				velocity2);	}}